# Api设计 - RESTFul

系统遵循RESTFul Api框架，部分存在争议或未规定的操作支持多种替换方案

## 1. 资源与URI

### 1.1 资源命名规范

- 对于某个资源的集合，如要列出全部文件，应使用可数名词复数

  - `/files`

  - `/users/114514/permissions`

  - `/groups/114514/members`

  *这时往往返回一个list，详情见**列表、集合与分页**部分*

- 对于单个资源，使用名词单数（可数或不可数）

  - `/users/114514/name`

- 对于动词，使用其名词形式

  - `/transactions`

概括：均使用名词，不限制单复数（要求符合资源的实际性质）

### 1.2 URI命名

- 使用 `_` 分割单词短语

- 使用 `/` 表示层级

  - 只操作用户的名字：`/users/114514/name`
  - 小组的成员：`/groups/114514/members`

  备注：不能无限分层级，是否支持分层和支持哪些分层都是由endpoint控制的

- 使用 `?` 设定限制（施加于集合，结果是集合）

  - 名字是`a`和名字是`b`的用户：`/users?name=a|b`

  备注：这种只适用于简单的相等查询，无法处理高级的查询，如*拥有某个权限的所有用户*

- 使用 `;` 表示同层级关系

  - 两个用户：`/users/114514;1919810`

  同级操作往往返回一个集合

> ​	案例：定位用户的几种方式：
>
> 	1. `/users/<uid1>;<uid2>;...`
> 	1. `/users?id=<uid1>|<uid2>|...`

## 2. 方法

可利用的HTTP方法有：

- GET：安全 幂等
- HEAD：安全 幂等
- PUT：不安全 幂等
- POST：不安全 不幂等
- PATCH：不安全 幂等
- DELETE：不安全 幂等

## 2.1 查询

查询资源是安全且幂等的，可以通过`HEAD`方法和`GET`方法实现

- `HEAD`：获取资源的元数据（不包含在正式返回中的内容）
  - 获取全部用户的数量：**HEAD** `/users`
  - **TODO**
- `GET`：获取资源的内容（正式返回）

这两种方法均支持同级查询和查询限制

## 2.2 增加

增加资源不安全，使用PUT时是幂等的，而POST则不是

- `PUT`：替换某个资源，不存在则创建，使用**客户端提供的ID**

  大部分的时候不应该允许客户端自定义ID，当接受到客户端自定义的ID时，可返回一个302，并分配一个安全的ID

  需要返回修改后的结果

  - 替换或创建一个记录：**PUT** `/records/114514`

- `POST`：新建一个资源，服务端会计算ID

  需要返回新建的内容

  - 新建一个用户：**POST** `/users`

只能用于普通资源，不得用于子资源（如`/users/114514/name`）

## 3. 响应

### 3.1 响应码

总体可以分为三类：

1. 成功（2xx）：直接返回内容
2. 重定向（3xx）：重定向，**不会出现在API响应中**
3. 客户端错误（4xx）：返回**标准错误模板**
4. 服务器错误（5xx）：返回**标准错误模板**

### 3.2 响应内容

任何时候都不应该包装响应内容

除了及特殊需求，任何时候均应该返回`application/json`

### 3.3 标准错误模板

```json
{
    "error": "password_or_username", // 错误的命名不需包含"error"，未知错误为"unknown"
    "details": _, // 可以为任意内容，如某个错误需要传输数据则体现在这里
    "backtrace": // 完整回溯(如果有)
` 0: std::backtrace_rs::backtrace::dbghelp::trace
  	at ...
  24: BaseThreadInitThunk
  25: RtlUserThreadStart`
}
```

